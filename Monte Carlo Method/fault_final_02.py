# -*- coding: utf-8 -*-
"""fault-final-02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PvPk-VDK6MTSDpQOhHFAvFEgDndxdUSI
"""

# Commented out IPython magic to ensure Python compatibility.
#################################################################################
##         This is the second question of the                                  ##
##          fault tolerant system final exam.                                  ##
##         Student Name: Yeganeh Aghamohammadi                                 ##
##         Student ID: 98208581                                                ## 
##         This is part a                                                      ##
#################################################################################

'''Monte Carlo simulation'''

########## First I import libraries
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline
import random

##### Definition of deadline and x1, x2, ... x5
deadline = 20
x1_a = 2 #ms
x5_a = x4_a = x3_a = x2_a = x1_a

f_list_a = []
f = 0
energy_all = []
num_of_examples = 10000
distribution_x1 = distribution_x2 = distribution_x3 = distribution_x4 = distribution_x5 = 0
for i in range(num_of_examples):
  ######## distributions: 
  distribution_x1 = (random.randrange(0,1999)/1000) * pow(10,-4) * x1_a
  distribution_x2 = (random.randrange(2000,3999)/1000) * pow(10,-4) * x2_a
  distribution_x3 = (random.randrange(4000,5999)/1000) * pow(10,-4) * x3_a
  distribution_x4 = (random.randrange(6000,7999)/1000) * pow(10,-4) * x4_a
  distribution_x5 = (random.randrange(8000,9999)/1000) * pow(10,-4) * x5_a

  f = distribution_x1 + distribution_x2 + distribution_x3 + distribution_x4 + distribution_x5
  f_list_a.append(f)


  ######## ENERGY:
  energy1_a = ((distribution_x1) / (pow(10,-4) * x1_a)) * (100*x1_a)
  energy2_a = ((distribution_x2) / (pow(10,-4) * x2_a)) * (100*x2_a)
  energy3_a = ((distribution_x3) / (pow(10,-4) * x3_a)) * (100*x3_a)
  energy4_a = ((distribution_x4) / (pow(10,-4) * x4_a)) * (100*x4_a)
  energy5_a = ((distribution_x5) / (pow(10,-4) * x5_a)) * (100*x5_a)

  e = energy1_a + energy2_a + energy3_a + energy4_a + energy5_a
  energy_all.append(e)



####### energy report:
arr_energy = np.array(energy_all)
all = 0
for i in range(num_of_examples):
  all += arr_energy[i]
energy_a = (all/num_of_examples)
energy_a

new1 = np.array(f_list_a)
m=0
for i in range(num_of_examples):
  m += new1[i]
probability_a = (m/num_of_examples)*100
print('probability_a = ', probability_a, 'energy_a = ', energy_a, 'nJ')



plt.plot(f_list_a)

########### Gaussian Graph of A ############

mu = np.mean(np.array(f_list_a))
sigma = np.std(np.array(f_list_a)) #You manually calculated it but you can also use this built-in function
data = np.random.normal(mu, sigma,num_of_examples)

count, bins, ignored = plt.hist(data, 30, normed=True)
plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) * np.exp( - (bins - mu)**2 / (2 * sigma**2) ),linewidth=2, color='r')

plt.show()

####################################################
##                                                ##
##                                                ##
##                 PART B                         ##
##                                                ##
##                                                ##
####################################################

##### Definition of deadline and x1, x2, ... x5
deadline = 20
x1_b = 1
x2_b = 1.5
x3_b = 2
x4_b = 2.5
x5_b = 3


f_list_b = []
f = 0
energy_all = []
num_of_examples = 10000
distribution_x1 = distribution_x2 = distribution_x3 = distribution_x4 = distribution_x5 = 0
for i in range(num_of_examples):
  distribution_x1 = (random.randrange(0,999)/1000) * pow(10,-4) * x1_b
  distribution_x2 = (random.randrange(1000,2499)/1000) * pow(10,-4) * x2_b
  distribution_x3 = (random.randrange(2500,4499)/1000) * pow(10,-4) * x3_b
  distribution_x4 = (random.randrange(4500,6999)/1000) * pow(10,-4) * x4_b
  distribution_x5 = (random.randrange(7000,9999)/1000) * pow(10,-4) * x5_b

  f = distribution_x1 + distribution_x2 + distribution_x3 + distribution_x4 + distribution_x5
  f_list_b.append(f)

  ######## ENERGY:
  energy1_b = ((distribution_x1) / (pow(10,-4) * x1_b)) * (100*x1_b)
  energy2_b = ((distribution_x2) / (pow(10,-4) * x2_b)) * (100*x2_b)
  energy3_b = ((distribution_x3) / (pow(10,-4) * x3_b)) * (100*x3_b)
  energy4_b = ((distribution_x4) / (pow(10,-4) * x4_b)) * (100*x4_b)
  energy5_b = ((distribution_x5) / (pow(10,-4) * x5_b)) * (100*x5_b)

  e = energy1_b + energy2_b + energy3_b + energy4_b + energy5_b
  energy_all.append(e)



####### energy report:
arr_energy = np.array(energy_all)
all = 0
for i in range(num_of_examples):
  all += arr_energy[i]
energy_b = (all/num_of_examples)
energy_b


#plt.plot(f_list_b)

new2 = np.array(f_list_b)
b=0
for i in range(num_of_examples):
  b += new2[i]
probability_b = (b/num_of_examples)*100
print('probability_b = ', probability_b, 'energy_b = ', energy_b, 'nJ')

plt.plot(f_list_b)

######## Gaussian Graph of B ###########


mu = np.mean(np.array(f_list_b))
sigma = np.std(np.array(f_list_b)) #You manually calculated it but you can also use this built-in function
data = np.random.normal(mu, sigma,num_of_examples)

count, bins, ignored = plt.hist(data, 30, normed=True)
plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) * np.exp( - (bins - mu)**2 / (2 * sigma**2) ),linewidth=2, color='r')

plt.show()

#plt.plot(data)